package validation

import (
	"fmt"
	"math"
	"regexp"
	"strings"
)

// Recipe represents the structure of a recipe generated by AI.
// These types are mirrored from the groq package to avoid circular dependencies.
type Recipe struct {
	RecipeName          string
	Description         string
	PrepTime            *int
	CookingTime         *int
	TotalTime           *int
	OriginalServings    *int
	DifficultyRating    *int
	FocusedDiet         string
	EstimatedCalories   *int
	Ingredients         []Ingredient
	Instructions        []Instruction
	Nutrition           Nutrition
	CuisineCategories   []string
	MealTypes           []string
	Occasions           []string
	DietaryRestrictions []string
	Equipment           []string
}

type Ingredient struct {
	OriginalQuantity string  `json:"original_quantity"`
	OriginalUnit     string  `json:"original_unit"`
	Quantity         float64 `json:"quantity"`
	Unit             string  `json:"unit"`
	Name             string  `json:"name"`
}

type Instruction struct {
	StepNumber  int    `json:"step_number"`
	Instruction string `json:"instruction"`
}

type Nutrition struct {
	Protein float64 `json:"protein"`
	Carbs   float64 `json:"carbs"`
	Fat     float64 `json:"fat"`
	Fiber   float64 `json:"fiber"`
}

type RecipeValidationResult struct {
	IsValid         bool
	Issues          []string
	HasPlaceholders bool
	QualityScore    int // 0-100
}

type RecipeOutputValidationConfig struct {
	MinIngredients      int
	MinInstructions     int
	MaxPlaceholderRatio float64
}

var placeholderPatterns = []*regexp.Regexp{
	regexp.MustCompile(`(?i)^n/?a$`),
	regexp.MustCompile(`(?i)^unknown$`),
	regexp.MustCompile(`(?i)^not specified$`),
	regexp.MustCompile(`(?i)^not provided$`),
	regexp.MustCompile(`(?i)^no recipe found$`),
	regexp.MustCompile(`(?i)^recipe$`),
	regexp.MustCompile(`(?i)^food$`),
	regexp.MustCompile(`(?i)^dish$`),
	regexp.MustCompile(`(?i)^to taste$`),
	regexp.MustCompile(`(?i)^as needed$`),
	regexp.MustCompile(`(?i)^optional$`),
	regexp.MustCompile(`(?i)^tbd$`),
	regexp.MustCompile(`(?i)^todo$`),
	regexp.MustCompile(`(?i)^placeholder$`),
	regexp.MustCompile(`^\[.*\]$`),
	regexp.MustCompile(`^<.*>$`),
	regexp.MustCompile(`(?i)^xxx+$`),
	regexp.MustCompile(`(?i)^pending$`),
}

var genericNamePatterns = []*regexp.Regexp{
	regexp.MustCompile(`(?i)^recipe$`),
	regexp.MustCompile(`(?i)^food$`),
	regexp.MustCompile(`(?i)^dish$`),
	regexp.MustCompile(`(?i)^meal$`),
	regexp.MustCompile(`(?i)^untitled$`),
	regexp.MustCompile(`(?i)^no name$`),
	regexp.MustCompile(`(?i)^generic recipe$`),
}

var genericInstructionPatterns = []*regexp.Regexp{
	regexp.MustCompile(`(?i)^follow recipe$`),
	regexp.MustCompile(`(?i)^cook as desired$`),
	regexp.MustCompile(`(?i)^prepare as usual$`),
	regexp.MustCompile(`(?i)^standard preparation$`),
	regexp.MustCompile(`(?i)^cook until done$`),
}

func DefaultRecipeValidationConfig() RecipeOutputValidationConfig {
	return RecipeOutputValidationConfig{
		MinIngredients:      2,
		MinInstructions:     2,
		MaxPlaceholderRatio: 0.2,
	}
}

// DetectPlaceholders checks if text contains placeholder content.
func DetectPlaceholders(text string) bool {
	trimmed := strings.TrimSpace(text)
	if trimmed == "" {
		return true
	}

	for _, pattern := range placeholderPatterns {
		if pattern.MatchString(trimmed) {
			return true
		}
	}

	return false
}

func isGenericName(name string) bool {
	trimmed := strings.TrimSpace(name)
	if len(trimmed) < 3 {
		return true
	}

	for _, pattern := range genericNamePatterns {
		if pattern.MatchString(trimmed) {
			return true
		}
	}

	return false
}

func isGenericInstruction(instruction string) bool {
	trimmed := strings.TrimSpace(instruction)
	if len(trimmed) < 10 {
		return true
	}

	for _, pattern := range genericInstructionPatterns {
		if pattern.MatchString(trimmed) {
			return true
		}
	}

	return false
}

// ValidateRecipe checks the recipe for placeholders, minimum requirements, and calculates a quality score.
func ValidateRecipe(recipe Recipe, config RecipeOutputValidationConfig) RecipeValidationResult {
	if recipe.RecipeName == "" {
		return RecipeValidationResult{
			IsValid:         false,
			Issues:          []string{"Recipe name is missing"},
			HasPlaceholders: true,
			QualityScore:    0,
		}
	}

	issues := []string{}
	placeholderCount := 0
	totalFields := 0

	// Check recipe name
	totalFields++
	if DetectPlaceholders(recipe.RecipeName) {
		issues = append(issues, "Recipe name is a placeholder")
		placeholderCount++
	} else if isGenericName(recipe.RecipeName) {
		issues = append(issues, "Recipe name is too generic")
	}

	// Check description
	totalFields++
	if DetectPlaceholders(recipe.Description) {
		placeholderCount++
	} else if recipe.Description != "" && len(recipe.Description) < 10 {
		issues = append(issues, "Description is too short")
	}

	// Check ingredients
	if len(recipe.Ingredients) < config.MinIngredients {
		issues = append(issues, fmt.Sprintf("Too few ingredients (%d, need at least %d)", len(recipe.Ingredients), config.MinIngredients))
	} else {
		validIngredients := 0
		for _, ingredient := range recipe.Ingredients {
			totalFields++
			if DetectPlaceholders(ingredient.Name) {
				placeholderCount++
			} else if ingredient.Name != "" && ingredient.Quantity != 0 && ingredient.Unit != "" {
				validIngredients++
			}
		}

		if validIngredients < config.MinIngredients {
			issues = append(issues, fmt.Sprintf("Too few valid ingredients with quantities (%d)", validIngredients))
		}
	}

	// Check instructions
	if len(recipe.Instructions) < config.MinInstructions {
		issues = append(issues, fmt.Sprintf("Too few instructions (%d, need at least %d)", len(recipe.Instructions), config.MinInstructions))
	} else {
		validInstructions := 0
		for _, inst := range recipe.Instructions {
			totalFields++
			if DetectPlaceholders(inst.Instruction) || isGenericInstruction(inst.Instruction) {
				placeholderCount++
			} else if inst.Instruction != "" && len(inst.Instruction) >= 10 {
				validInstructions++
			}
		}

		if validInstructions < config.MinInstructions {
			issues = append(issues, fmt.Sprintf("Too few detailed instructions (%d)", validInstructions))
		}
	}

	// Check nutrition data (nice to have)
	totalFields++
	if recipe.Nutrition.Protein == 0 && recipe.Nutrition.Carbs == 0 && recipe.Nutrition.Fat == 0 {
		placeholderCount++
	}

	// Calculate placeholder ratio
	placeholderRatio := 0.0
	if totalFields > 0 {
		placeholderRatio = float64(placeholderCount) / float64(totalFields)
	} else {
		placeholderRatio = 1.0
	}

	hasPlaceholders := placeholderRatio > config.MaxPlaceholderRatio
	if hasPlaceholders {
		issues = append(issues, fmt.Sprintf("Too many placeholders (%d%%, max %d%%)", int(placeholderRatio*100), int(config.MaxPlaceholderRatio*100)))
	}

	// Calculate quality score (0-100)
	qualityScore := 100.0

	// Deduct for issues
	qualityScore -= float64(len(issues) * 10)

	// Deduct for placeholders
	qualityScore -= placeholderRatio * 30

	// Deduct for missing optional fields
	if recipe.PrepTime == nil {
		qualityScore -= 5
	}
	if recipe.CookingTime == nil {
		qualityScore -= 5
	}
	if recipe.DifficultyRating == nil {
		qualityScore -= 5
	}
	if len(recipe.CuisineCategories) == 0 {
		qualityScore -= 5
	}
	if len(recipe.MealTypes) == 0 {
		qualityScore -= 5
	}

	finalScore := int(math.Max(0, math.Min(100, qualityScore)))

	return RecipeValidationResult{
		IsValid:         len(issues) == 0 && !hasPlaceholders && finalScore >= 50,
		Issues:          issues,
		HasPlaceholders: hasPlaceholders,
		QualityScore:    finalScore,
	}
}
