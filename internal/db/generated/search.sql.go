// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const searchRecipes = `-- name: SearchRecipes :many
SELECT r.id, r.created_by, r.name, r.description, r.prep_time, r.cook_time, r.servings, r.difficulty, r.origin_url, r.embedding, r.is_public, r.created_at, r.updated_at, 1 - (r.embedding <=> $1::vector) as similarity
FROM recipes r
WHERE (r.created_by = $2 OR r.is_public = true)
ORDER BY r.embedding <=> $1::vector
LIMIT $3
`

type SearchRecipesParams struct {
	Column1   pgvector.Vector
	CreatedBy pgtype.UUID
	Limit     int32
}

type SearchRecipesRow struct {
	ID          pgtype.UUID
	CreatedBy   pgtype.UUID
	Name        string
	Description pgtype.Text
	PrepTime    pgtype.Int4
	CookTime    pgtype.Int4
	Servings    pgtype.Int4
	Difficulty  pgtype.Text
	OriginUrl   pgtype.Text
	Embedding   pgvector.Vector
	IsPublic    bool
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Similarity  int32
}

func (q *Queries) SearchRecipes(ctx context.Context, arg SearchRecipesParams) ([]SearchRecipesRow, error) {
	rows, err := q.db.Query(ctx, searchRecipes, arg.Column1, arg.CreatedBy, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchRecipesRow
	for rows.Next() {
		var i SearchRecipesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.Name,
			&i.Description,
			&i.PrepTime,
			&i.CookTime,
			&i.Servings,
			&i.Difficulty,
			&i.OriginUrl,
			&i.Embedding,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
